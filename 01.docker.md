# Docker

## 가상화

낮은 사양의 컴퓨터를 여러 대 사용하는 것보다 높은 사양의 컴퓨터 한 대를 사용하는 편이 비용, 설치공간, 인력, 서버운영, 하드웨어 크기 등 여러 면에서 더 경제적입니다.

#### 하이퍼바이저 가상화

가상환경을 생성하고 CPU와 메모리 리소스를 할당. 호스트 OS는 물리 서버를 직접 관리하고 게스트 OS는 리소스를 나눠 사용하는 물리적인 공간. 분리된 게스트 OS를 가상머신이라고 부름. 가상머신에는 WAS, 데이터베이스 등의 프로그램을 프로세스로 실행. 프로세스가 하드웨어 리소스를 사용하려면 OS에 리소스 사용을 요청해야 합니다. OS에는 이러한 요청을 처리하는 커널이라는 중요한 구성요소가 있습니다. `하이퍼바이저`는 **게스트 OS의 커널과 호스트 OS의 커널간 상호작용**을 가능하게 합니다.  
하이퍼바이저 프로그램 : VirtualBox, VMWare.

#### 컨테이너 가상화

하이퍼바이저 가상화보다 빠르며 소비자의 요구사항이 빠르게 변화함에 따라 애플리케이션도 신속하게 대응할 수 있어야 하기 때문입니다. 리눅스 컨테이너(LXC) 기술에서 시작되었으며 별도의 소프트웨어 없이 커널의 기능만으로 격리된 공간을 만듭니다. 프로세스, 파일시스템, 네트워크 등을 분리하는 네임스페이스와 리소스 사용량을 관리하는 cgroups 기술을 활용하며 이렇게 격리된 공간을 `컨테이너`라고 부릅니다. **커널을 공유하기 때문에 호스트 OS와 다른 종류의 OS를 실행할 수 없다**는 단점이 있음

#### 컨테이너 플랫폼

          컨테이너 플랫폼 =  컨테이너 엔진  +  컨테이너 런타임

`컨테이너 엔진`은 사용자 요청에 따라 컨테이너를 관리하고,  
`컨테이너 런타임`은 커널과 직접 소통해서 실제 컨테이너를 생성

```
[컨테이너 표준]
   └─ OCI (Open Container Initiative)
        ├─ Image Spec
        └─ Runtime Spec

[컨테이너 엔진 / 런타임]
   ├─ Docker Engine
   ├─ containerd
   ├─ CRI-O
   └─ Podman

[오케스트레이션]
   └─ Kubernetes
```

`Docker`는 컨테이너 생태계의 시작점이고, 실제 운영 표준 엔진은 `containerd` / `CRI-O` 쪽으로 이동했습니다.  
현재는 `Docker`는 `개발/학습용`으로 컨테이너 플랫폼의 입문 도구로 사용하고 실제 `운영환경`에서는 경량 런타임 엔진인 `containerd`나 `CRI-O` 사용합니다.

**containerd**

- 현재 운영 표준
- Docker에서 분리된 경량의 컨테이너 엔진
- 가볍고 빠르다
- `kubernetes(k8s)의 기본엔진`으로 Docker 없이도 동작

**CRI-O**

- Kubernetes만을 위한 컨테이너 런타임으로 `kubernetes(k8s)`에 최적화
- `보안`/경량

**Podman**

- `Red Hat` 계열 Docker 대체 도구
- Docker CLI 호환
- 데몬 없음
- 보안 정책이 엄격한 서버에 사용

```
클라이언트 ->    도커 CLI    ->    도커 데몬
              (도커 명령어)
```

## 윈도우에서 도커 실행환경 구축

### 1. wsl 설치

```sh
c:\> wsl --install
```

### 2. docker desktop 설치

- Windows/macOS에서 Docker를 쓰기 위해 Linux 환경을 대신 만들어주는 관리 도구입니다.”
- "컨테이너 실행 환경 + 관리 도구 패키지"

Docker Desktop 기능  
✔ 자동 설정

- Linux VM 생성
- Docker Engine 설치
- 네트워크 / 볼륨 설정

✔ 관리 기능

- 컨테이너 / 이미지 관리 UI
- 로그 확인
- 리소스 제한(CPU/메모리)

✔ 개발자 기능

- Docker Compose
- Kubernetes (옵션)
- WSL 연동

## [아마존 리눅스에 도커 설치](https://docs.aws.amazon.com/ko_kr/serverless-application-model/latest/developerguide/install-docker.html)

```bash
# 설치한 패키지 및 패키지 캐시를 업데이트
sudo yum update -y

# 최신 Docker Community Edition 패키지를 설치
sudo yum install -y docker

# 설치한 Docker 버전 확인
docker -v

# Docker 서비스를 시작  (sudo systemctl start docker)
sudo service docker start

# sudo를 사용하지 않고도 docker 명령을 실행할 수 있도록 Docker 그룹에 ec2-user를 추가
sudo usermod -aG docker ec2-user

#로그아웃 후 다시 로그인해서 새 docker 그룹 권한을 취득
exit

# sudo 없이도 Docker 명령을 실행할 수 있는지 확인
docker ps
```

## [도커 CLI 명령어](https://docs.docker.com/reference/cli/docker/)

```
도움말
  docker -v
  docker --help
  docker 명령어 --help

이미지 명령                   생략형
  docker image ls          =  docker images    <= 이미지 리스트 (= docker image ls)
  docker image tag         =  docker tag       <= 이미지 이름 변경
  docker image rm          =  docker rmi       <= 이미지 삭제 (= docker image rm)
  docker image push        =  docker push      <= 도커허브 레지스트리에 이미지 업로드
  docker image pull        =  docker pull      <= 도커허브 레지스트리에 이미지 다운로드
  docker image build       =  docker build     <= 이미지 생성

컨테이너 명령                 생략형
  docker container run     =  docker run       <= 컨테이너 실행
  docker container ps      =  docker ps        <= 컨테이너 리스트 (= docker container ls)
  docker container logs    =  docker logs      <= 컨테이너 로그 확인
  docker container exec    =  docker exec      <= 컨테이너 내부에 접속(또는 컨테이너 내부에 접속하지 않고 명령어만 실행)
  docker container start   =  docker start     <= 컨테이너 시작
  docker container restart =  docker restart   <= 컨테이너 재시작
  docker container stop    =  docker stop      <= 컨테이너 중지
  docker container rm      =  docker rm        <= 컨테이너 삭제
  docker container commit  =  docker commit    <= 실행중인 컨테이너로 이미지 생성

네트워크 명령(생략형 없슴)
  docker network create       <= 네트워크를 생성
  docker network inspect      <= 네트워크의 상세 정보를 확인
  docker network ls           <= 네트워크 목록을 확인
  docker network rm           <= 지정한 네트워크를 삭제
  docker network prune        <= 현재 아무 컨테이너에도 접속하지 않은 네트워크를 모두 삭제
  docker network connect      <= 네트워크에 컨테이너를 새로이 접속
  docker network disconnect   <= 네트워크에서 컨테이너의 접속을 끊음

볼륨 명령(생략형 없슴)
  docker volume create       <= 볼륨을 생성
  docker volume inspect      <= 볼륨의 상세 정보를 확인
  docker volume ls           <= 볼륨 목록을 확인
  docker volume rm           <= 지정한 볼륨을 삭제
  docker volume prune        <= 현재 마운트되지 않은 볼륨을 모두 삭제

도커허브 접속
  docker login     <= 도커허브(레지스트리)에 로그인

```

## 도커 이미지로 mysql DB서버 구축

■ 이미지 다운받고 컨테이너 실행

```sh
docker create volume vtest
docker run -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=admin -v vtest:/var/lib/mysql --name mysql  mysql:8.0

# ex) docker run -d -p [호스트 port]:[컨테이 port] -e [환경 변수]=[값]
#                  -v [호스트경로]:[컨테이너경로] [docker image]:[tag]
#
#   -d : 백그라운드 실행(--detach)
#   -p : 호스트OS와 컨테이너 포트 매핑(--publish)
#   -e : 환경변수 설정(--env)
#   -v : 호스트OS와 컨테이너 볼륨 매핑(--volume)
#   --name : 컨테이너 이름 지정
```

■ 컨테이너 리스트 확인

```sh
docker ps -a

#   -a : 모든 컨테이너(all. 기본은 실행중인 컨테이너만 조회)
```

■ 컨테이너 접속

```sh
docker exec -it mysql bash      : 종료하고 나올때는 exit

#   -i : STDIN 열기(--interactive)
#   -t : TTY 할당(--tty)
```

■ mysql db서버 접속

```
mysql -u root -p
```

■ 데이터베이스, 테이블 생성

```
sql>
create database shop;
show databases;
show tables;
use shop;
create table emp ( username varchar(20), password varchar(20) );
insert into emp values ('scott','1111');
select * from emp;
```

■ mysql 로그아웃

```sh
sql> exit
```

■ 컨테이너 빠져나오기

```sh
exit
```

■ 컨테이너 리스트 확인

```sh
docker ps -a
```

■ 컨테이너 중지

```sh
docker stop mysql
```

■ 컨테이너 삭제

```sh
docker rm mysql
```

■ 이미지 리스트

```sh
docker images
```

■ 이미지 삭제

```sh
docker rmi 이미지id
```

## 도커 이미지 생성

■ 1. 빌드해서 배포파일(jar) 생성
메이븐인 경우

```bash
mvn clean package -DskipTests
```

그래이들인 경우

```bash
gradlew clean build
```

<img src="./images/gradle01.png">

■ 2. 도커 이미지 생성하고 허브에 업로드하기

A. Dockerfile 생성

```
FROM openjdk:21
WORKDIR /app
ARG JAR_FILE=target/\*.jar
COPY ${JAR_FILE} app.jar
ENV TZ=Asia/Seoul
EXPOSE 8080
ENTRYPOINT ["java","-jar","app.jar"]
```

B. 도커 이미지 생성
docker build -t cyannara/project .
docker images

C. 컨테이너 실행
docker run -d -p 80:80 --name project cyannara/project
docker ps -a
docker logs -f project

D. 브라우저 확인
http://localhost

E. 컨테이너 중지하고 삭제
docker stop project
docker rm project

F. 도커 이미지 업로드
docker login -u cyannara -p dckr_pat_tPoaoh3Dk8YRUQmf8ELqWS7Tf5I
docker push cyannara/project

=======================================================================

C. 도커 컨테이너 실행

# 기존 이미지 삭제

local
docker rmi cyannara/project
docker build -t cyannara/project .  
 docker login -u cyannara -p dckr_pat_ClQftrkvOlRTGX40zrPspNRI08o
docker push cyannara/project

ec2
docker stop project
docker rm project
docker rmi cyannara/project
docker run -d --name project -p 80:80 -v /home:/home cyannara/project

D. 브라우저에서 확인
http://ec2서버ip:80

## mysql db 서버 + springboot was

■ 1. mysql 컨테이너 실행

mysql.sh

```bash
  docker network create springboot-mysql-net
  docker volume create fileupload-volume
  docker run -d -p 3306:3306 \
       -e MYSQL_ROOT_PASSWORD=admin \
       -e MYSQL_DATABASE=edudb  \
       -e MYSQL_USER=jdbctest  \
       -e MYSQL_PASSWORD=jdbctest  \
       -e TZ=Asia/Seoul   \
       -v vtest:/var/lib/mysql  \
       --net springboot-mysql-net \
       --name mysql-container  mysql:8.0
```

■ 2. bootapp 컨테이너 재시작

bootapp.sh

```bash
docker volume create fileupload-volume
docker network create springboot-mysql-net
```

```bash
docker stop edu
docker rm edu
docker rmi cyannara/edu
docker run -d --name edu \
           -p 80:9090 \
           -v fileupload-volume:/uploadtest \
           --net springboot-mysql-net \
           cyannara/project
```

■ 3. 브라우저에서 확인
http://ec2서버ip:80
